#include <iostream>
#include <vector>
#include <unordered_set>
#include <unordered_map>

#include "main.h"
#include "Tests.h"
#include "EvaluateStatistics.h"

using namespace std;

/*
Этот файл содержит решение первой задачи из собеседования. На собеседовании было сделано переборное решение  
сложности N^4 (в четвертой степени). Ниже решение, которое показывает линейную зависимость от количества 
исходных данных. В решении описана сложность решения - обяснено, почему она линейная.
Также линейная сложность решения подтверждается тестами. К решению приложен график.
При запуске решение выводит данные, полностью подтверждающиме линейную зависимость.
*/


CountTripletsResult countTriplets(const vector<long>& sourceArray, long r) {
	// То, что написано ниже, прекрасно работает! Проверено. (См. график)
	// Я хочу ОЧЕНЬ использовать условие, что тройка содержит числа, кратные r & r^2:
	// (t1, t2, t3) где t1=a, t2=a*r, t3=a*r^2
	// Считаю неразумным просто бегать по массиву и перебирать все элементы при сложности n^3 или n^4
	// я понимаю, что среди натуральных чисел квадратов относительно мало: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, ...
	// И чисел, кратных квадратам, тоже весьма мало, по сравнению с общим числом натуральных чисел!
	// А это значит, если набор чисел в исходном массиве sourceArray более-менее равномерно распределен,
	// то я весьма сокращу перебор, если выкину из перебора те числа, которые не подходят под общий вид:
	// a, a*r, a*r*r
	// Обращаю внимание, что самое большое число в тройке - t3, - однозначно задает остальные числа тройки t2 и t1:
	//		t2 = t3/r,  t1= t3/(r*r)
	// Другими словами, если я найду в массиве все числа t3, которые кратны r^2, 
	// на основе их я могу отобрать из исходного массива все числа t1 и t2. 
	// А это многократно позволит сократить перебор: в идеале он будет линейный, что существенно 
	// меньше чем n^3 и n^4. 
	// Я сделаю ассоциативный массив, ключами которого будут числа t1, t2, t3 РЕАЛЬНО ВСТРЕЧАЮЩИЕСЯ В ТРОЙКАХ 
	// А значениями массива будут позиции этих чисел в исходном массиве - индексы. И на основе этого я быстро 
	// посчитаю все значения

	long allPereborOperationCount = 0;
	long innerN4PereborOperationCount = 0;

	// Шаг 1: найти все уникальные числа t3 и сохранить их в отдельном hashSet
	long squareR = r * r;
	std::unordered_set<long> t3Set;
	for (long i : sourceArray)
	{
		allPereborOperationCount++;
		if (i % squareR == 0) {
			t3Set.insert(i);
		}
	}

	// Шаг 2: на основе чисел t3 вычислить уникальные все t2 и t1, поместить их в отдельный hashSet t1t2t3Set
	std::unordered_set<long> t1t2t3Set(t3Set.size() * 3);
	for (long t3 : t3Set)
	{
		allPereborOperationCount++;

		// Числа t2 & t1 точно есть, т.к. в t3Set точно находятся числа, делящиеся на r^2
		long t2 = t3 / r;
		long t1 = t2 / r;

		t1t2t3Set.insert(t1);
		t1t2t3Set.insert(t2);
		t1t2t3Set.insert(t3);
	}


	// Шаг 3: создать ассоциативный массив, где ключами являются числа из наборе t1t2t3Set.
	// А значениями будут списки позиций, где в исходном массиве встречаются эти элементы
	// Этой информации достаточно для расчета кол-ва троек
	// Важно: позиции в значениях ассоциативного массива будут упорядочены по возрастанию, 
	// т.к. мы идем по циклу по возрастанию индекса! Это важно для слещующего этапа
	unordered_map<long, vector<size_t>> positionMap(t1t2t3Set.size());
	auto endSet = t1t2t3Set.end();
	long sourceArraySize = sourceArray.size();	// Чтоб не расчитывалось значениена каждой итерации цикла
	for (size_t position = 0; position < sourceArraySize; position++)
	{
		allPereborOperationCount++;

		long item = sourceArray[position];
		if (t1t2t3Set.find(item) != endSet)
		{
			// этот элемент есть в наших тройках - нам нужна его позиция!
			positionMap[item].push_back(position);
		}

	}

	// Шаг 4: расчет комбинаций. Переборный.
	// positionMap содержит все числа t1, t2, t3. А нам нужен перебор только по числам t3, 
	// ибо тройка задается числом t3. У нас есть для этого t3Set, которые содержат уникальные значения t3
	long tripleCount = 0;
	for (long t3 : t3Set) {
		allPereborOperationCount++;

		// Числа t2 & t1 точно есть, т.к. в t3Set точно находятся числа, делящиеся на r^2
		long t2 = t3 / r;
		long t1 = t2 / r;

		// t1Positions, t2Positions, t3Positions - содержат наборы позиций чисел в тройке (t1, t2, t3)
		// И эти наборы отсотрированы по возрастанию!!!
		// Ради этого и был весь сыр-бор!
		// Тут и начитается перебор, но перебор не всего, а только нужного. У нас был перебор n^4
		// а здесь прореженный перебор только нужного ((n/100)^4). 
		// 100 взято от фонаря, это определяет реальный набор данных, но это гораздо меньше на много порядков
		const vector<size_t>& t3Positions = positionMap[t3];
		const vector<size_t>& t2Positions = positionMap[t2];
		const vector<size_t>& t1Positions = positionMap[t1];

		size_t t1PositionsSize = t1Positions.size();
		for (size_t pos1Index = 0; pos1Index < t1PositionsSize; pos1Index++)
		{
			allPereborOperationCount++;

			auto pos1 = t1Positions[pos1Index];
			size_t t2PositionsSize = t2Positions.size();
			for (size_t pos2Index = 0; pos2Index < t2PositionsSize; pos2Index++)
			{
				allPereborOperationCount++;

				auto pos2 = t2Positions[pos2Index];
				if (pos1 > pos2)	// нарушается условие, что индексы t1, t2, t3 должны монотонно возрастать
					break;

				size_t t3PositionsSize = t3Positions.size();
				for (size_t pos3Index = 0; pos3Index < t3PositionsSize; pos3Index++) {
					allPereborOperationCount++;
					innerN4PereborOperationCount++;	// Это то, что должно было расти в червертой степени. Ввел для оценки реального перебора!

					auto pos3 = t3Positions[pos3Index];
					if (pos2 > pos3)	// нарушается условие, что индексы t1, t2, t3 должны монотонно возрастать
						break;

					tripleCount++;
				}
			}

		}
	}

	CountTripletsResult result;
	result.countTriplets = tripleCount;
	result.innerN4PereborOperationCount = innerN4PereborOperationCount;
	result.allPereborOperationCount = allPereborOperationCount;
	return  result;

}

/// <summary>
/// Оценка сложности алгоритма
/// Я добавил создание 2 множеств и заполнение их. 
/// Каждое множество заполняется за 1 проход цикла. Вставка значения в множество О(1). Сложность линейная.
/// Я добавил создание 1 ассоциативного массива. И заполнение его. Вставка значения в ассоциативный массив О(1). 
///			Сложность линейная.
/// Перебор где 4 вложенных цикла сильно сокращен. У том варианте, который предлагался 
/// на совместной сессии программировая, сложность была n^4 (на самом деле меньше, т.к.массив 
/// был отсортирован и в последних двух циклах в среднем перебор заканчивался на половине цикла, 
/// ибо отсортировано и было условие на возрастание индекса)
/// 
/// Здесь тоже вроде червертая степень, но не полного размера n, а (n/100) . И n^4 и (n/100)^4 - это принципиално разные вещи!
/// В реальности вместо 100 будет другое число, которое зависит от набора данных.
/// И это многократно перекрывает затраты, которые я понес, на создание двух множеств и асооциативного массива!
/// Эта овчинка стоит выделки!!!
/// 
/// ОПЫТНЫМ ПУТЕМ ВЫЯСНИЛ, ЧТО ЭТО РЕШЕНИЕ ДАЕТ ЛИНЕЙНУЮ ЗАВИСИМОСТЬ ОТ КОЛИЧЕСТВА ДАННЫХ.
/// ЦЕЛЬ ДОСТИГНУТА ПОЛНОСТЬЮ!!!
/// </summary>





void main() {
	// проверка правильности алгоритма. Простые тесты, доказывающие, что все работает правильно
	CheckAllTests();

	PrintStatistics(5000, 100000, 5000);
}